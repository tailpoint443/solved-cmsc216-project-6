Download Link: https://assignmentchef.com/product/solved-cmsc216-project-6
<br>
In this project, you will write the guts of a shell that will support boolean operations, pipes, and file redirection. The project has two deadlines:

<h1>2      Procedure</h1>

<h2>2.1      Obtain the project files</h2>

We have supplied several files for your use in this project:

<strong>command.h </strong>defines the tree structure that the parser will produce from a command line, and the conjunctions that join commands into a line.

<strong>d8sh.c </strong>is the main shell loop. You need not modify this file, but it may be useful to inspect for generating test cases.

<strong>executor.c </strong>is where you must implement the function int execute(struct tree *t), which will take a tree from the parser and execute the commands in the tree. The return value of execute may be used as you like, e.g., for exit status or for a process id, if you choose to call execute recursively.

<strong>executor.h </strong>is the declaration of execute, used by the parser.

<strong>lexer.c </strong>is the lexer, which splits a command line into tokens, generated by flex. <strong>lexer.h </strong>declares lexer related functions referenced by d8sh.

<strong>parser.tab.c </strong>is the parser, which assembles tokens into a parsed tree, generated by bison. <strong>parser.tab.h </strong>is a part of the parser, generated by bison, referenced by lexer.c.

<strong>run-all-tests.csh </strong>checks for Makefile and d8sh, then compares the output of your d8sh using the command lines in the testing subdirectory.

These files are contained in ~/216public/project6. Your code for this project should be contained in your ~/216/project6 subdirectory.

<h2>2.2      Create a Makefile</h2>

Create a Makefile that we will use to build your shell. Section 3.1 lists the targets you are required to implement, as well as other requirements for your Makefile.

<h2>2.3      Implement and test the shell</h2>

You must implement your shell program by supplying the necessary code in executor.c. As you implement various features of the shell, you can test them by either interactively running d8sh while typing in commands, or you can create text files with one command per line, and use redirection to feed them as input to your shell.

The video <a href="https://tinyurl.com/yadjttla">https://tinyurl.com/yadjttla</a> can help you understand what you need to implement for this project. Start watching the video at time 19:13.

<h1>3      Specifications</h1>

<strong>3.1 </strong>Makefile

Your Makefile should be set up so that all programs are built using separate compilation (i.e., source files are turned into object files, which are then linked together in a separate step). All object files should be built using the class flags.

You must have the following targets in your Makefile:

<ol>

 <li>all: make all executables</li>

 <li>clean: delete all object files and executables</li>

 <li>o, parser.tab.o, executor.o, and d8sh.o, the object files for the parsing code and shell code</li>

 <li>d8sh: the executable created by linking the parsing object file with the shell object files and linked with the readline library using -lreadline.</li>

</ol>

We will use the Makefile you provide to build the public test executables on the submit server; if there is no Makefile, your shell program will not be built, and you will not receive credit for <strong>any </strong>tests.

You may have other targets, for example “test”.

<h2>3.2     The Shell</h2>

The shell you will implement will include some, but not all features, of the shell you use on grace. The features your shell supports will include pipes, input and output redirection, and the “&amp;&amp;” operator.

The parser may permit a few more operations that you need not support. In particular, the “||” and “;” operators exist in the format, but need not be supported by your code.

To invoke the parser, d8sh uses readline(), then yy_scan_string(buffer), followed by yyparse(). (Typically, a bison parser would load a file such as your C source. Here, we are using this system to operate on a string.) When the parser constructs a complete tree from a command line, it invokes your execute() function.

You are given the main shell program in d8sh.c: your task is to implement the execute() function called by main(). Once the full d8sh program is linked together from the four object files, d8sh should function as a normal shell, with some limitations as described below.

The syntax for the features we want you to implement is very similar to the shell syntax you should be familiar with from your experience working with the Unix environment. These are the specific features your shell must provide:

<ol>

 <li><strong>File redirection</strong>: by using the &lt; and &gt; tokens, a user should be able to redirect standard input and output in the same manner as is done in the tcsh and bash shells.</li>

</ol>

If a file is created by output redirection, the file should be created using permissions 0664.

In the case of a multi-program pipeline, file input redirection may be applied to the first program (before the first pipe character), and file output redirection may be applied to the final program. A shell must print “Ambiguous input redirect.” or “Ambiguous output redirect.” if a user tries to provide a redirected file and a pipe at the same time. For example, the following is illegal “echo hello &gt; x | cat”.

<ol start="2">

 <li><strong>Piping</strong>: if programs are separated by pipe characters (“|”) on a command line, then the standard output of the program to the left of the pipe character is to be connected to the standard input of the program to the right of the pipe character, creating a pipeline.</li>

</ol>

When running a pipeline, the shell must start all of the processes, but not return to print another prompt until all processes have exited. You will need to determine how to fork all the processes piped together and then wait for them all to finish.

<ol start="3">

 <li><strong>Subshells</strong>: when expressions are surrounded by parentheses, the command is executed in its own shell, forked from the parent. This ensures that environment changes (such as changing the current directory) are contained to the subshell.</li>

</ol>

As you can see from the code in d8sh.c, the shell prompts the user for a command, parses the command, and then attempts to execute the command. To execute the command, you must use the struct tree * parameter to see which options are set, and perform the steps necessary to execute the command as requested.

Should you encounter any errors in executing the command, your shell <strong>must not terminate </strong>– children of the shell may terminate, but the code you write in execute() must not cause the parent (shell) process to terminate. A user should not cause the shell to die because he/she, for example, mistyped the name of a program to execute.

If your shell cannot exec any process, it should print, “Failed to execute %s” with the name of the program that failed. Other failed system calls should print using perror, e.g., perror(“fork”). The shell is already configured for parse errors to print as “Parse error: %s” via the yyerror() function.

<h1>4      Example Trees</h1>

You may want to print out the contents of each parse tree you work on. Here are some examples.

echo hello &amp;&amp; echo goodbye | grep oo

Note that the pipe operation has a higher precedence than and. As a result, “hello” is printed to stdout and does not pass through grep. The grep command prints all lines that include a given string, so will print “goodbye” because it includes “oo”.

cat command.h | cat | cat | cat | cat

The “cat” tool can either read input from arguments or from stdin, then pass it to stdout. Using pipe, fork, dup2, and exec to build pipelines in tree form can be subtle. The contents of command.h should appear on the output. (This is a better example than it is a test; tests may use tac instead of cat to reverse the file.)

true &amp;&amp; false &amp;&amp; [ -e a.c ] &amp;&amp; echo 2-1 | bc &amp;&amp; [ -x b.c ]

Again, pipe has a higher precedence. Execution should stop at the first false. true runs the /usr/bin/true program, whose only purpose is to exit(0), a successful result. (See: “man true” and “man false” for more information. There are a few trivial programs like this, for example, “yes” and “seq”. You must use the wait() or waitpid() functions to determine whether the program exited successfully).

(head -2 &amp;&amp; head -2) &lt; lexer.h

Note how the shell prints the first four lines of lexer.h if given this command. Beware, however, the first head command might use buffered I/O and thereby slurp more data than just the first two lines, leaving the second head command to print two lines from the middle of a longer file. (It does work on grace and submit.) More reliable would be to redirect output instead of input.

pwd &amp;&amp; cd .. &amp;&amp; pwd

This will output the current directory, change to its parent, and output the parent. For the next command, the current directory will be the parent.

(pwd &amp;&amp; cd ..) &amp;&amp; pwd

This will output the current directory and change to its parent in a subshell, then output the current directory again (unchanged). For the next command, the current directory will unchanged.

mkdir ../bkup &amp;&amp; tar cf – . | (cd ../bkup &amp;&amp; tar xf -)

This is an example of using cd in a subshell in practice to backup a directory. The cd affects only the second tar (extract rather than create). This creates a directory, ../otherdir, then copies the contents of the current directry into it using tar. The current working directory after this command is unchanged (not bkup). From a subshell, environment (working directory) changes do not escape.

(cd ../bkup &amp;&amp; tar cf – .) | tar xf –

If the previous example created a backup, this one restores it. The cd affects only the first tar, leaving the current working directory for the next command where it was. The command will fail if “bkup” is not present.

<h1>5        Important Points and Hints</h1>

<ol>

 <li>Start by handling nodes with conjunction NONE, i.e., no pipes, no ands. Add redirection, pipes, and the and operation incrementally.</li>

 <li>execute() must implement internally the commands “cd” and “exit”. The “cd” command should change to the user’s home directory (getenv(“HOME”)) if given no arguments.</li>

 <li>Be sure to wait for <strong>all </strong>child processes of your shell to complete; failing to do so will cause a collection of zombie processes to accumulate and tie up Grace system resources.</li>

 <li>Be careful that any fork loops you write terminate at some point, before a Grace system administrator has to kill them.</li>

 <li>You may wish to print the contents of the tree before execution. Each node is either an internal node of the tree, representing a PIPE or an AND, or a leaf node, representing a command with argv set. Any node, including internal nodes may have input and output redirection. Your shell should mimic real shells for the following commands:</li>

</ol>

(head &amp;&amp; head) &lt; lexer.h

(head &lt; lexer.h &amp;&amp; head &lt; lexer.h)

(cat command.h | cat – command.h)

(cat &lt; command.h | cat – command.h)

<ol start="6">

 <li>You are permitted to translate the tree structure into whatever representation you prefer. (This is not encouraged.)</li>

 <li>You need not free the data or nodes in the parse tree. Yes, this will leak memory.</li>

 <li>Closing the correct file descriptors for a pipe at the correct time can be tricky. All the file descriptors for writing must be closed before a reader will see the end of file and exit. If the shell hangs, there’s probably a process waiting for more input that will never come.</li>

 <li>Don’t get excited and modify the shell prompt to make it look more shell like; that may have bad consequences on the submit server.</li>

 <li>Please consider using git locally to track your changes; for example, supporting AND may break your design for PIPE, and it may be useful to go back in time to find your working solution.</li>

 <li>Make sure your executor.c file has your student id (e.g., 111XXX…) NOT your directory id. There are tests that check for the presence of this id.</li>

 <li>Make sure you code compiles without warnings, otherwise you will lose credit. Make sure you comment out the print tree function provided with executor.c once you have no longer use for it. There are tests that check for warnings.</li>

 <li>You need to add to executor.c any .h files that allow you to fork, exec*, etc.</li>

 <li>The message ”Failed to execute %s” … should be sent to standard error.</li>

 <li>Use standard output for ambiguous output redirect and ambiguous input redirect messages.</li>

 <li>If chdir fails, use perror to print an error message. For example, perror(location) where location is the directory.</li>

 <li>If both ambiguous input and output redirect take place, only one message will be printed ( ”Ambiguous output redirect.” )</li>

</ol>